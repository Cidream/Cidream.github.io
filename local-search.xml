<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/06/16/%E6%96%87%E7%AB%A0%E6%A8%A1%E6%9D%BF/"/>
    <url>/2024/06/16/%E6%96%87%E7%AB%A0%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="1-站点地图🗺"><a href="#1-站点地图🗺" class="headerlink" title="-1 站点地图🗺"></a>-1 站点地图🗺</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><h2 id="1-引入"><a href="#1-引入" class="headerlink" title="1 引入"></a>1 引入</h2><h2 id="2-结构思想"><a href="#2-结构思想" class="headerlink" title="2 结构思想"></a>2 结构思想</h2><h2 id="3-定义结构"><a href="#3-定义结构" class="headerlink" title="3 定义结构"></a>3 定义结构</h2><h2 id="4-实现结构"><a href="#4-实现结构" class="headerlink" title="4 实现结构"></a>4 实现结构</h2><h2 id="5-优化结构"><a href="#5-优化结构" class="headerlink" title="5 优化结构"></a>5 优化结构</h2><h2 id="6-时间复杂度"><a href="#6-时间复杂度" class="headerlink" title="6 时间复杂度"></a>6 时间复杂度</h2><h2 id="7-扩展结构"><a href="#7-扩展结构" class="headerlink" title="7 扩展结构"></a>7 扩展结构</h2><h2 id="8-代码模板"><a href="#8-代码模板" class="headerlink" title="8 代码模板"></a>8 代码模板</h2><h2 id="last-总结"><a href="#last-总结" class="headerlink" title="last 总结"></a>last 总结</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/06/16/%E7%AE%97%E6%B3%95/"/>
    <url>/2024/06/16/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>算法基础课相关代码模板<br>活动链接 —— 算法基础课<br>快速排序算法模板 —— 模板题 AcWing 785. 快速排序<br>void quick_sort(int q[], int l, int r)<br>{<br>    if (l &gt;&#x3D; r) return;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span> (i &lt; j)<br>&#123;<br>    <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>    <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>    <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>&#125;<br><span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br></code></pre></td></tr></table></figure><p>}<br>归并排序算法模板 —— 模板题 AcWing 787. 归并排序<br>void merge_sort(int q[], int l, int r)<br>{<br>    if (l &gt;&#x3D; r) return;</p><pre><code class="hljs">int mid = l + r &gt;&gt; 1;merge_sort(q, l, mid);merge_sort(q, mid + 1, r);int k = 0, i = l, j = mid + 1;while (i &lt;= mid &amp;&amp; j &lt;= r)    if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];    else tmp[k ++ ] = q[j ++ ];while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];while (j &lt;= r) tmp[k ++ ] = q[j ++ ];for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</code></pre><p>}<br>整数二分算法模板 —— 模板题 AcWing 789. 数的范围<br>bool check(int x) {&#x2F;* … *&#x2F;} &#x2F;&#x2F; 检查x是否满足某种性质</p><p>&#x2F;&#x2F; 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：<br>int bsearch_1(int l, int r)<br>{<br>    while (l &lt; r)<br>    {<br>        int mid &#x3D; l + r &gt;&gt; 1;<br>        if (check(mid)) r &#x3D; mid;    &#x2F;&#x2F; check()判断mid是否满足性质<br>        else l &#x3D; mid + 1;<br>    }<br>    return l;<br>}<br>&#x2F;&#x2F; 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：<br>int bsearch_2(int l, int r)<br>{<br>    while (l &lt; r)<br>    {<br>        int mid &#x3D; l + r + 1 &gt;&gt; 1;<br>        if (check(mid)) l &#x3D; mid;<br>        else r &#x3D; mid - 1;<br>    }<br>    return l;<br>}<br>浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根<br>bool check(double x) {&#x2F;* … *&#x2F;} &#x2F;&#x2F; 检查x是否满足某种性质</p><p>double bsearch_3(double l, double r)<br>{<br>    const double eps &#x3D; 1e-6;   &#x2F;&#x2F; eps 表示精度，取决于题目对精度的要求<br>    while (r - l &gt; eps)<br>    {<br>        double mid &#x3D; (l + r) &#x2F; 2;<br>        if (check(mid)) r &#x3D; mid;<br>        else l &#x3D; mid;<br>    }<br>    return l;<br>}<br>高精度加法 —— 模板题 AcWing 791. 高精度加法<br>&#x2F;&#x2F; C &#x3D; A + B, A &gt;&#x3D; 0, B &gt;&#x3D; 0<br>vector<int> add(vector<int> &amp;A, vector<int> &amp;B)<br>{<br>    if (A.size() &lt; B.size()) return add(B, A);</p><pre><code class="hljs">vector&lt;int&gt; C;int t = 0;for (int i = 0; i &lt; A.size(); i ++ )&#123;    t += A[i];    if (i &lt; B.size()) t += B[i];    C.push_back(t % 10);    t /= 10;&#125;if (t) C.push_back(t);return C;</code></pre><p>}<br>高精度减法 —— 模板题 AcWing 792. 高精度减法<br>&#x2F;&#x2F; C &#x3D; A - B, 满足A &gt;&#x3D; B, A &gt;&#x3D; 0, B &gt;&#x3D; 0<br>vector<int> sub(vector<int> &amp;A, vector<int> &amp;B)<br>{<br>    vector<int> C;<br>    for (int i &#x3D; 0, t &#x3D; 0; i &lt; A.size(); i ++ )<br>    {<br>        t &#x3D; A[i] - t;<br>        if (i &lt; B.size()) t -&#x3D; B[i];<br>        C.push_back((t + 10) % 10);<br>        if (t &lt; 0) t &#x3D; 1;<br>        else t &#x3D; 0;<br>    }</p><pre><code class="hljs">while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();return C;</code></pre><p>}<br>高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法<br>&#x2F;&#x2F; C &#x3D; A * b, A &gt;&#x3D; 0, b &gt;&#x3D; 0<br>vector<int> mul(vector<int> &amp;A, int b)<br>{<br>    vector<int> C;</p><pre><code class="hljs">int t = 0;for (int i = 0; i &lt; A.size() || t; i ++ )&#123;    if (i &lt; A.size()) t += A[i] * b;    C.push_back(t % 10);    t /= 10;&#125;while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();return C;</code></pre><p>}<br>高精度除以低精度 —— 模板题 AcWing 794. 高精度除法<br>&#x2F;&#x2F; A &#x2F; b &#x3D; C … r, A &gt;&#x3D; 0, b &gt; 0<br>vector<int> div(vector<int> &amp;A, int b, int &amp;r)<br>{<br>    vector<int> C;<br>    r &#x3D; 0;<br>    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i – )<br>    {<br>        r &#x3D; r * 10 + A[i];<br>        C.push_back(r &#x2F; b);<br>        r %&#x3D; b;<br>    }<br>    reverse(C.begin(), C.end());<br>    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();<br>    return C;<br>}<br>一维前缀和 —— 模板题 AcWing 795. 前缀和<br>S[i] &#x3D; a[1] + a[2] + … a[i]<br>a[l] + … + a[r] &#x3D; S[r] - S[l - 1]<br>二维前缀和 —— 模板题 AcWing 796. 子矩阵的和<br>S[i, j] &#x3D; 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]<br>一维差分 —— 模板题 AcWing 797. 差分<br>给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c<br>二维差分 —— 模板题 AcWing 798. 差分矩阵<br>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c<br>位运算 —— 模板题 AcWing 801. 二进制中1的个数<br>求n的第k位数字: n &gt;&gt; k &amp; 1<br>返回n的最后一位1：lowbit(n) &#x3D; n &amp; -n<br>双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和<br>for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )<br>{<br>    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;</p><pre><code class="hljs">// 具体问题的逻辑</code></pre><p>}<br>常见问题分类：<br>    (1) 对于一个序列，用两个指针维护一段区间<br>    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作<br>离散化 —— 模板题 AcWing 802. 区间和<br>vector<int> alls; &#x2F;&#x2F; 存储所有待离散化的值<br>sort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序<br>alls.erase(unique(alls.begin(), alls.end()), alls.end());   &#x2F;&#x2F; 去掉重复元素</p><p>&#x2F;&#x2F; 二分求出x对应的离散化的值<br>int find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置<br>{<br>    int l &#x3D; 0, r &#x3D; alls.size() - 1;<br>    while (l &lt; r)<br>    {<br>        int mid &#x3D; l + r &gt;&gt; 1;<br>        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;<br>        else l &#x3D; mid + 1;<br>    }<br>    return r + 1; &#x2F;&#x2F; 映射到1, 2, …n<br>}<br>区间合并 —— 模板题 AcWing 803. 区间合并<br>&#x2F;&#x2F; 将所有存在交集的区间合并<br>void merge(vector<PII> &amp;segs)<br>{<br>    vector<PII> res;</p><pre><code class="hljs">sort(segs.begin(), segs.end());int st = -2e9, ed = -2e9;for (auto seg : segs)    if (ed &lt; seg.first)    &#123;        if (st != -2e9) res.push_back(&#123;st, ed&#125;);        st = seg.first, ed = seg.second;    &#125;    else ed = max(ed, seg.second);if (st != -2e9) res.push_back(&#123;st, ed&#125;);segs = res;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
