<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2023/08/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2023/08/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-站点地图🗺"><a href="#1-站点地图🗺" class="headerlink" title="-1 站点地图🗺"></a>-1 站点地图🗺</h1><p><img src="/img/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%AE%97%E6%B3%95%E5%9C%B0%E5%9B%BE.png"></p><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h1><p>接下来我们要学习<strong>三种数据结构</strong>，它们的作用都是<strong>维护区间</strong>，<strong>基本原理</strong>都是将<strong>大区间</strong>划分为<strong>小区间</strong>，维护<strong>小区间</strong>合并到<strong>大区间</strong>中。 他们的<strong>区间划分</strong>方法不同，对<strong>结构</strong>的<strong>维护方法</strong>也不同，也<strong>各有所长</strong>，这种<strong>数据结构代码短难度小</strong>，但<strong>思想不容易理解</strong>且<strong>应用广</strong>。</p><h1 id="1-引入"><a href="#1-引入" class="headerlink" title="1 引入"></a>1 引入</h1><blockquote><p><strong>树状数组（Binary Indexed Tree）</strong> 是一种可以<strong>动态维护(查询、修改) 区间前缀和</strong>的<strong>数据结构</strong>。</p></blockquote><h1 id="2-结构思想"><a href="#2-结构思想" class="headerlink" title="2 结构思想"></a>2 结构思想</h1><p>利用<strong>二进制</strong>将<strong>大区间</strong>分成若干个<strong>小区间</strong>，<br>根据任意<strong>正整数</strong>关于2的<strong>不重复次幂</strong>的<strong>唯一分解性质</strong>，<br><strong>正整数X</strong> 的<strong>二进制</strong>：$x &#x3D; a_{k-1} \cdot a_{k - 2} \dots a_2 \cdot a_1 \cdot a_0$<br>其中<strong>等于1的位</strong>是：${ a_{i_1},a_{i_2},\dots,a_{i_m} }$ $(i_1 &gt; i_2 &gt; \dots &gt; i_m)$<br>则<strong>正整数 X</strong> 可以被<strong>分解</strong>成：$x &#x3D; 2^{i_1} + 2^{i_2} + \dots + 2^{i_m}$<br>进一步地,<strong>区间</strong>$[ 1 , X ]$ 可以<strong>分成</strong> $O(log x)$ 个<strong>小区间</strong>:</p><p>1.长度为$2^{i_1}$的<strong>小区间</strong> $[1,2^{i_1}]$<br>2.长度为$2^{i_2}$的<strong>小区间</strong> $[2^{i_1}+1,2^{i_1} + 2^{i_2}]$<br>3.长度为$2^{i_3}$的<strong>小区间</strong> $[2^{i_1} + 2^{i_2} +1,2^{i_1} + 2^{i_2} + 2^{i_3}]$<br>$\dots\dots$<br>m.长度为$2^{i_m}$的<strong>小区间</strong> $[2^{i_1} + 2^{i_2} + \dots + 2^{i_{m-1}}+1,2^{i_1} + 2^{i_2} + \dots + 2^{i_m}]$</p><p>下面这段<strong>代码</strong>作用是将<strong>大区间</strong>按如上<strong>方法</strong>划分成<strong>小区间</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d, %d]n&quot;</span>, x - (x &amp; -x) + <span class="hljs-number">1</span>, x);<br>x -= x &amp; -x;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-定义结构"><a href="#3-定义结构" class="headerlink" title="3 定义结构"></a>3 定义结构</h1><p><strong>树状数组</strong>就是一种利用上述<strong>思想</strong>的<strong>数据结构</strong>，其用途是<strong>维护区间的前缀和</strong>。<br>对于给定的<strong>区间a</strong>，我们建立<strong>数组c</strong>,其中$c[x]$保存<strong>序列a</strong>的<strong>区间</strong>$[x - lowbit(x)+1, x]$中<strong>所有</strong>数的<strong>和</strong>，即$$c[x]&#x3D;\sum_{i &#x3D; x - lowbit(x) + 1}^{x}a[i]$$<br>事实上，将N个<strong>区间</strong>排列可以得到一个如下图所示的<strong>树形结构</strong>，图中<strong>最下边</strong>一行是<strong>N</strong>个<strong>叶子节点</strong>， 代表数值</p><p>$a[1$~$N]$。 该<strong>结构</strong>满足以下<strong>性质</strong>:</p><p>每个<strong>内部节点</strong>$c[x]$的<strong>子节点个数</strong>等于$lowbit(x)$的<strong>位数</strong>,<br>除<strong>树根</strong>外，每个<strong>内部节点</strong>$c[x]$的<strong>父节点</strong>是$c[x + lowbit(x)]$.。</p><p>如果<strong>N</strong>不是$2^n$(<strong>n</strong>为<strong>正整数</strong>)，那么<strong>树状数组</strong>就是一个具有<strong>同样性质</strong>的<strong>森林结构</strong>。</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png"></p><h1 id="4-实现结构"><a href="#4-实现结构" class="headerlink" title="4 实现结构"></a>4 实现结构</h1><p><font color=#008000><strong>初始化建树</strong></font>，</p><p><font color=#008000><strong>查询前缀和</strong></font>，累加所有大区间中的小区间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; x; x -= x &amp; -x) ans += c[x];<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color=#008000><strong>修改元素</strong></font>，修改所有与该元素有关的区间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(; x &lt;= N; x += x &amp; -x) c[x] += y;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-优化结构"><a href="#5-优化结构" class="headerlink" title="5 优化结构"></a>5 优化结构</h1><h1 id="6-时间复杂度"><a href="#6-时间复杂度" class="headerlink" title="6 时间复杂度"></a>6 时间复杂度</h1><table><thead><tr><th align="center">操作</th><th align="center">时间复杂度</th></tr></thead><tbody><tr><td align="center"><strong>未优化初始化建树</strong></td><td align="center">O(N log N)</td></tr><tr><td align="center"><strong>优化初始化建树</strong></td><td align="center">O(N)</td></tr><tr><td align="center"><strong>查询前缀和</strong></td><td align="center">O(log N)</td></tr><tr><td align="center"><strong>修改元素</strong></td><td align="center">O(log N)</td></tr></tbody></table><h1 id="7-扩展结构"><a href="#7-扩展结构" class="headerlink" title="7 扩展结构"></a>7 扩展结构</h1><h1 id="8-代码模板"><a href="#8-代码模板" class="headerlink" title="8 代码模板"></a>8 代码模板</h1><h1 id="last-总结"><a href="#last-总结" class="headerlink" title="last 总结"></a>last 总结</h1>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树状数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树状数组</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/07/20/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/07/20/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-站点地图🗺"><a href="#1-站点地图🗺" class="headerlink" title="-1 站点地图🗺"></a>-1 站点地图🗺</h1><p><img src="/img/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E7%AE%97%E6%B3%95%E5%9C%B0%E5%9B%BE.png"></p><h1 id="0-引入"><a href="#0-引入" class="headerlink" title="0 引入"></a>0 引入</h1><blockquote><p><strong>并查集</strong>是一种可以<strong>动态维护(合并、查询)</strong> 若干个<strong>不重叠</strong>的集合的<strong>数据结构</strong>。</p></blockquote><h1 id="1-定义集合"><a href="#1-定义集合" class="headerlink" title="1 定义集合"></a>1 定义集合</h1><p>我们可以在<strong>每个集合</strong>中选择<strong>任意一个固定元素</strong>作为<strong>集合</strong>的<strong>代表</strong>——这种方法叫做“<strong>代表元表示法</strong>”。</p><h1 id="2-定义结构"><a href="#2-定义结构" class="headerlink" title="2 定义结构"></a>2 定义结构</h1><blockquote><p><strong><font color=#008000>case 1 链式结构</font> 用邻接表表示集合</strong><br>  这种结构可以<strong>高效合并集合</strong>，但<strong>查询元素归属集合</strong>会浪费<strong>大量的时间</strong>。</p></blockquote><blockquote><p><strong><font color=#008000>case 2 线性结构</font> 用一个数组存储集合归属</strong><br>  这种结构可以<strong>查询元素归属集合</strong>，但<strong>高效合并集合</strong>会浪费<strong>大量的时间</strong>。</p></blockquote><blockquote><p><strong><font color=#008000>case 3 链式结构</font> 用邻接表表示集合</strong><br>  <strong>集合</strong>会以构成<strong>若干棵树</strong>，<strong>整个结构</strong>构成一片<strong>森林</strong>，这种结构可以较好地<strong>合并集合</strong>和<strong>查询集合归属</strong>所以<strong>效率更高</strong>。</p></blockquote><h1 id="3-实现结构"><a href="#3-实现结构" class="headerlink" title="3 实现结构"></a>3 实现结构</h1><p>我们可以将<strong>根节点</strong>的<strong>代表元</strong>设为指向自己 <strong>（根结点）</strong>。<br><font color=#008000><strong>合并集合</strong></font>，将其中一棵<strong>树根</strong>向<strong>另一棵树</strong>的<strong>树根</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> fa[SIZE];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) fa[i] = i;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x == fa[x]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(fa[x]);<br>&#125;<br></code></pre></td></tr></table></figure><p><font color=#008000><strong>查询集合归属</strong></font>，从该<strong>节点向上递归</strong>找着<strong>根节点</strong>从而确定<strong>集合归属</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span><br><span class="hljs-function"></span>&#123;<br>fa[<span class="hljs-built_in">get</span>(x)] = <span class="hljs-built_in">get</span>(y);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-优化结构"><a href="#4-优化结构" class="headerlink" title="4 优化结构"></a>4 优化结构</h1><p>以上的并查集<strong>查询效率效率仍然较低</strong>。我们将引入两种<strong>优化方式</strong>，分别是<strong>路径压缩</strong>和<strong>按秩合并（启发式合并）</strong>。</p><h3 id="🔮路径压缩"><a href="#🔮路径压缩" class="headerlink" title="🔮路径压缩"></a>🔮路径压缩</h3><p>在<strong>case 1</strong>中，直接使用<strong>数组保存集合代表</strong>的<strong>查询效率很高</strong>我们考虑把<strong>两种思路</strong>进行结合，实际上，我们并不关心<strong>这棵树的具体形态</strong>。这就意味着下图<strong>两棵树</strong>是<strong>等价</strong>的。<br><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9.png"><br>因此我们可以在每次执行<strong>get操作</strong>的同时把访问过的<strong>每个节点（查询元素的全部祖先）</strong>都指向<strong>树根</strong>，这种<strong>优化方法</strong>被称为<strong>路径压缩</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> fa[SIZE];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) fa[i] = i;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x == fa[x]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">get</span>(fa[x]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🔮按秩合并（启发式合并）"><a href="#🔮按秩合并（启发式合并）" class="headerlink" title="🔮按秩合并（启发式合并）"></a>🔮按秩合并（启发式合并）</h3><p>在<strong>合并集合</strong>的过程中，<strong>树高</strong>越<strong>高</strong>则<strong>效率</strong>越<strong>低</strong>，这启发我们将<strong>小结构合并到大结构</strong>使<strong>树高</strong>尽可能的<strong>小</strong>，我们可以在<strong>合并集合</strong>时比较<strong>树高的大小（集合大小）</strong>，在<strong>实际应用</strong>中应用较少。</p><h1 id="5-时间复杂度"><a href="#5-时间复杂度" class="headerlink" title="5 时间复杂度"></a>5 时间复杂度</h1><table><thead><tr><th align="center">优化</th><th align="center">时间复杂度</th><th align="center">注解</th></tr></thead><tbody><tr><td align="center">无优化</td><td align="center">$O(n)$</td><td align="center">退化成链</td></tr><tr><td align="center">单使用路径压缩</td><td align="center">$O(log n)$</td><td align="center">效率较高</td></tr><tr><td align="center">单使用按秩合并</td><td align="center">$O(log n)$</td><td align="center">效率较高</td></tr><tr><td align="center">同时使用两种优化</td><td align="center">$O(α(n))$</td><td align="center">近似常数</td></tr></tbody></table><h1 id="6-扩展结构"><a href="#6-扩展结构" class="headerlink" title="6 扩展结构"></a>6 扩展结构</h1><p><strong>并查集</strong>能在一张<strong>无向图</strong>中<strong>维护节点</strong>之间的<strong>连通性</strong>，<strong>并查集</strong>可以<strong>动态维护</strong>许多具有<strong>传递性的关系</strong>，所以我们可以将<strong>树</strong>上<strong>每条边</strong>上赋上一个<strong>权值</strong>，保存<strong>节点（$x$）</strong> 到父<strong>节点（$fa[x]$）</strong> 之间的<strong>边权</strong>，<strong>路径压缩</strong>的过程中，<strong>统计每个节点</strong>到<strong>树根</strong>之间<strong>路径</strong>的一些<strong>信息</strong>，这就是“<strong>边带权的并查集</strong>”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == fa[x]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-type">int</span> root = <span class="hljs-built_in">get</span>(fa[x]);  <span class="hljs-comment">// 递归计算集合代表</span><br>d[x] += d[fa[x]];       <span class="hljs-comment">// 维护d数组——对边权求和</span><br><span class="hljs-keyword">return</span> fa[x] = root;    <span class="hljs-comment">// 路径压缩 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span><br><span class="hljs-function"></span>&#123;<br>x = <span class="hljs-built_in">get</span>(x), y = <span class="hljs-built_in">get</span>(y);<br>fa[x] = y, d[x] = size[y];<br>size[y] += size[x];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-代码模板"><a href="#7-代码模板" class="headerlink" title="7 代码模板"></a>7 代码模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 并查集</span><br><span class="hljs-type">int</span> fa[SIZE];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) fa[i] = i;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x == fa[x]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">get</span>(fa[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span><br><span class="hljs-function"></span>&#123;<br>fa[<span class="hljs-built_in">get</span>(x)] = <span class="hljs-built_in">get</span>(y);<br>&#125;<br><span class="hljs-comment">// 边带权的并查集</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x == fa[x]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-type">int</span> root = <span class="hljs-built_in">get</span>(fa[x]);  <span class="hljs-comment">// 递归计算集合代表</span><br>d[x] += d[fa[x]];       <span class="hljs-comment">// 维护d数组——对边权求和</span><br><span class="hljs-keyword">return</span> fa[x] = root;    <span class="hljs-comment">// 路径压缩 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span><br><span class="hljs-function"></span>&#123;<br>x = <span class="hljs-built_in">get</span>(x), y = <span class="hljs-built_in">get</span>(y);<br>fa[x] = y, d[x] = size[y];<br>size[y] += size[x];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="last-总结"><a href="#last-总结" class="headerlink" title="last 总结"></a>last 总结</h1><p>这个<strong>数据结构</strong>巧妙的解决<strong>集合</strong>的基本问题，后续我们会陆陆续续做些题<strong>巩固</strong>一下所学知识。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>并查集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
