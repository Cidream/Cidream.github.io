<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2023/07/27/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2023/07/27/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>$$ \{ \} $$</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树状数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/07/20/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/07/20/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="0-引入"><a href="#0-引入" class="headerlink" title="0 引入"></a>0 引入</h1><blockquote><p><strong>并查集</strong>是一种可以<strong>动态维护(合并、查询)</strong> 若干个<strong>不重叠</strong>的集合的<strong>数据结构</strong>。</p></blockquote><h1 id="1-定义集合"><a href="#1-定义集合" class="headerlink" title="1 定义集合"></a>1 定义集合</h1><p>我们可以在<strong>每个集合</strong>中选择<strong>任意一个固定元素</strong>作为<strong>集合</strong>的<strong>代表</strong>——这种方法叫做“<strong>代表元表示法</strong>”。</p><h1 id="2-定义结构"><a href="#2-定义结构" class="headerlink" title="2 定义结构"></a>2 定义结构</h1><blockquote><p><strong><font color=#008000>case 1 链式结构</font> 用邻接表表示集合</strong><br>  这种结构可以<strong>高效合并集合</strong>。但<strong>查询元素归属集合</strong>会浪费<strong>大量的时间</strong>。</p></blockquote><blockquote><p><strong><font color=#008000>case 2 线性结构</font> 用一个数组存储集合归属</strong><br>  这种结构可以<strong>查询元素归属集合</strong>。但<strong>高效合并集合</strong>会浪费<strong>大量的时间</strong>。</p></blockquote><blockquote><p><strong><font color=#008000>case 3 链式结构</font> 用邻接表表示集合</strong><br>  <strong>集合</strong>会以构成<strong>若干棵树</strong>，<strong>整个结构</strong>构成一片<strong>森林</strong>，这种结构可以较好地<strong>合并集合</strong>和<strong>查询集合归属</strong>所以<strong>效率更高</strong>。</p></blockquote><h1 id="3-实现结构"><a href="#3-实现结构" class="headerlink" title="3 实现结构"></a>3 实现结构</h1><p>我们可以将<strong>根节点</strong>的<strong>代表元</strong>设为指向自己 <strong>（根结点）</strong>。<br><font color=#008000><strong>合并集合</strong></font>，将其中一棵<strong>树根</strong>向<strong>另一棵树</strong>的<strong>树根</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> fa[SIZE];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) fa[i] = i;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == fa[x]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(fa[x]);<br>&#125;<br></code></pre></td></tr></table></figure><p><font color=#008000><strong>查询集合归属</strong></font>，从该<strong>节点向上递归</strong>找着<strong>根节点</strong>从而确定<strong>集合归属</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>fa[<span class="hljs-built_in">get</span>(x)] = <span class="hljs-built_in">get</span>(y);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-优化结构"><a href="#4-优化结构" class="headerlink" title="4 优化结构"></a>4 优化结构</h1><p>以上的并查集<strong>查询效率效率仍然较低</strong>。我们将引入两种<strong>优化方式</strong>，分别是<strong>路径压缩</strong>和<strong>按秩合并（启发式合并）</strong>。</p><h3 id="🔮路径压缩"><a href="#🔮路径压缩" class="headerlink" title="🔮路径压缩"></a>🔮路径压缩</h3><p>在<strong>case 1</strong>中，直接使用<strong>数组保存集合代表</strong>的<strong>查询效率很高</strong>我们考虑把<strong>两种思路</strong>进行结合，实际上，我们并不关心<strong>这棵树的具体形态</strong>。这就意味着下图<strong>两棵树</strong>是<strong>等价</strong>的。<br><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9.png"><br>因此我们可以在每次执行<strong>get操作</strong>的同时把访问过的<strong>每个节点（查询元素的全部祖先）</strong>都指向<strong>树根</strong>，这种<strong>优化方法</strong>被称为<strong>路径压缩</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> fa[SIZE];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) fa[i] = i;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == fa[x]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">get</span>(fa[x]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🔮按秩合并（启发式合并）"><a href="#🔮按秩合并（启发式合并）" class="headerlink" title="🔮按秩合并（启发式合并）"></a>🔮按秩合并（启发式合并）</h3><p>在<strong>合并集合</strong>的过程中，<strong>树高</strong>越<strong>高</strong>则<strong>效率</strong>越<strong>低</strong>，这启发我们将<strong>小结构合并到大结构</strong>使<strong>树高</strong>尽可能的<strong>小</strong>，我们可以在<strong>合并集合</strong>时比较<strong>树高的大小（集合大小）</strong>，在<strong>实际应用</strong>中应用较少。</p><h1 id="5-时间复杂度"><a href="#5-时间复杂度" class="headerlink" title="5 时间复杂度"></a>5 时间复杂度</h1><table><thead><tr><th>优化</th><th>时间复杂度</th><th>注解</th></tr></thead><tbody><tr><td>无优化</td><td>$O(n)$</td><td>退化成链</td></tr><tr><td>单使用路径压缩</td><td>$O(log n)$</td><td>效率较高</td></tr><tr><td>单使用按秩合并</td><td>$O(log n)$</td><td>效率较高</td></tr><tr><td>同时使用两种优化</td><td>$O(α(n))$</td><td>近似常数</td></tr></tbody></table><h1 id="6-扩展结构"><a href="#6-扩展结构" class="headerlink" title="6 扩展结构"></a>6 扩展结构</h1><p><strong>并查集</strong>能在一张<strong>无向图</strong>中<strong>维护节点</strong>之间的<strong>连通性</strong>，<strong>并查集</strong>可以<strong>动态维护</strong>许多具有<strong>传递性的关系</strong>，所以我们可以将<strong>树</strong>上<strong>每条边</strong>上赋上一个<strong>权值</strong>，保存<strong>节点（$x$）</strong> 到父<strong>节点（$fa[x]$）</strong> 之间的<strong>边权</strong>，<strong>路径压缩</strong>的过程中，<strong>统计每个节点</strong>到<strong>树根</strong>之间<strong>路径</strong>的一些<strong>信息</strong>，这就是“<strong>边带权的并查集</strong>”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == fa[x]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-type">int</span> root = <span class="hljs-built_in">get</span>(fa[x]);  <span class="hljs-comment">// 递归计算集合代表</span><br>d[x] += d[fa[x]];       <span class="hljs-comment">// 维护d数组——对边权求和</span><br><span class="hljs-keyword">return</span> fa[x] = root;    <span class="hljs-comment">// 路径压缩 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>x = <span class="hljs-built_in">get</span>(x), y = <span class="hljs-built_in">get</span>(y);<br>fa[x] = y, d[x] = size[y];<br>size[y] += size[x];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-代码模板"><a href="#7-代码模板" class="headerlink" title="7 代码模板"></a>7 代码模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 并查集</span><br><span class="hljs-type">int</span> fa[SIZE];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) fa[i] = i;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == fa[x]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">get</span>(fa[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>fa[<span class="hljs-built_in">get</span>(x)] = <span class="hljs-built_in">get</span>(y);<br>&#125;<br><span class="hljs-comment">// 边带权的并查集</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == fa[x]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-type">int</span> root = <span class="hljs-built_in">get</span>(fa[x]);  <span class="hljs-comment">// 递归计算集合代表</span><br>d[x] += d[fa[x]];       <span class="hljs-comment">// 维护d数组——对边权求和</span><br><span class="hljs-keyword">return</span> fa[x] = root;    <span class="hljs-comment">// 路径压缩 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>x = <span class="hljs-built_in">get</span>(x), y = <span class="hljs-built_in">get</span>(y);<br>fa[x] = y, d[x] = size[y];<br>size[y] += size[x];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="last-总结"><a href="#last-总结" class="headerlink" title="last 总结"></a>last 总结</h1><p>这个<strong>数据结构</strong>巧妙的解决<strong>集合</strong>的基本问题，后续我们会陆陆续续做些题<strong>巩固</strong>一下所学知识。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>并查集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
