<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/07/20/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/07/20/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="step-0-引入"><a href="#step-0-引入" class="headerlink" title="step 0 引入"></a>step 0 引入</h1><blockquote><p><strong>并查集</strong>是一种可以<strong>动态维护</strong>(合并、查询)若干个<strong>不重叠</strong>的集合的<strong>数据结构</strong>。</p></blockquote><h1 id="step-1-定义集合"><a href="#step-1-定义集合" class="headerlink" title="step 1 定义集合"></a>step 1 定义集合</h1><p>我们可以在每个集合中选择任意一个固定元素作为集合的代表——这种方法叫做“<strong>代表元表示法</strong>”。</p><h1 id="step-2-定义结构"><a href="#step-2-定义结构" class="headerlink" title="step 2 定义结构"></a>step 2 定义结构</h1><blockquote><p>** <font color=#008000>case 1 链式结构</font> 用邻接表表示集合**<br>  这种结构可以<strong>高效合并集合</strong>。但<strong>查询元素归属集合</strong>会浪费<strong>大量的时间</strong>。</p></blockquote><blockquote><p>** <font color=#008000>case 2 线性结构</font> 用一个数组存储集合归属**<br>  这种结构可以<strong>查询元素归属集合</strong>。但<strong>高效合并集合</strong>会浪费<strong>大量的时间</strong>。</p></blockquote><blockquote><p><strong><font color=#008000>case 3 链式结构</font> 用邻接表表示集合</strong><br>  <strong>所有集合</strong>会以构成<strong>一片森林</strong>，这种结构可以较好地<strong>合并集合</strong>和<strong>查询集合归属</strong>所以<strong>效率更高</strong>。</p></blockquote><h1 id="step-3-实现结构"><a href="#step-3-实现结构" class="headerlink" title="step 3 实现结构"></a>step 3 实现结构</h1><p>我们可以将<strong>根节点</strong>的<strong>代表元</strong>设为指向自己（根结点）。<br><font color=#008000><strong>合并集合</strong></font>，将其中一棵<strong>树根</strong>向<strong>另一棵树</strong>的<strong>树根</strong>。<br><font color=#008000><strong>查询集合归属</strong></font>，从该<strong>节点向上递归</strong>找着<strong>根节点</strong>从而确定<strong>集合归属</strong>。</p><h1 id="step-4-优化结构"><a href="#step-4-优化结构" class="headerlink" title="step 4 优化结构"></a>step 4 优化结构</h1><p>以上的并查集<strong>查询效率效率仍然较低</strong>。我们将引入两种<strong>优化方式</strong>，分别是<strong>路径压缩</strong>和<strong>按秩合并（启发式合并）</strong>。</p><h3 id="🔮路径压缩"><a href="#🔮路径压缩" class="headerlink" title="🔮路径压缩"></a>🔮路径压缩</h3><p>在<strong>case 1</strong>中，直接使用<strong>数组保存集合代表</strong>的<strong>查询效率很高</strong>我们考虑把<strong>两种思路</strong>进行结合，实际上，我们并不关心<strong>这棵树的具体形态</strong>。这就意味着下图<strong>两棵树</strong>是<strong>等价</strong>的。<br><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9.png"><br>因此我们可以在每次执行<strong>get操作</strong>的同时把访问过的<strong>每个节点（查询元素的全部祖先）</strong>都指向<strong>树根</strong>，这种<strong>优化方法</strong>被称为<strong>路径压缩</strong>。</p><h3 id="🔮按秩合并（启发式合并）"><a href="#🔮按秩合并（启发式合并）" class="headerlink" title="🔮按秩合并（启发式合并）"></a>🔮按秩合并（启发式合并）</h3><p>在<strong>合并集合</strong>的过程中，<strong>树高</strong>越<strong>高</strong>则<strong>效率</strong>越<strong>低</strong>，这启发我们将<strong>小结构合并到大结构</strong>使<strong>树高</strong>尽可能的<strong>小</strong>，我们可以在<strong>合并集合</strong>时比较<strong>树高的大小（集合大小）</strong>，在<strong>实际应用</strong>中应用较少。</p><h1 id="step-5-时间复杂度"><a href="#step-5-时间复杂度" class="headerlink" title="step 5 时间复杂度"></a>step 5 时间复杂度</h1><table><thead><tr><th>优化</th><th>时间复杂度</th><th>注解</th></tr></thead><tbody><tr><td>无优化</td><td>O(n)</td><td>退化成链</td></tr><tr><td>单使用路径压缩</td><td>O(log n)</td><td>效率较高</td></tr><tr><td>单使用按秩合并</td><td>O(log n)</td><td>效率较高</td></tr><tr><td>同时使用两种优化</td><td>O(α(n)）</td><td>近似常数</td></tr></tbody></table><h1 id="step-6-代码模板"><a href="#step-6-代码模板" class="headerlink" title="step 6 代码模板"></a>step 6 代码模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 并查集</span><br><span class="hljs-type">int</span> fa[SIZE];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) fa[i] = i;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == fa[x]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">get</span>(fa[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>fa[<span class="hljs-built_in">get</span>(x)] = <span class="hljs-built_in">get</span>(y);<br>&#125;<br><span class="hljs-comment">// 边带权的并查集</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == fa[x]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-type">int</span> root = <span class="hljs-built_in">get</span>(fa[x]);  <span class="hljs-comment">// 递归计算集合代表</span><br>d[x] += d[fa[x]];       <span class="hljs-comment">// 维护d数组——对边权求和</span><br><span class="hljs-keyword">return</span> fa[x] = root;    <span class="hljs-comment">// 路径压缩 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>x = <span class="hljs-built_in">get</span>(x), y = <span class="hljs-built_in">get</span>(y);<br>fa[x] = y, d[x] = size[y];<br>size[y] += size[x];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
